% This general-purpose optimization routine aims to minimize funcToOptimize
% starting from the initial guess startingX, via proposals generated by
% proposalFunc (the two functions are specified via function handles). When
% optimizing a function whose inputs have lower and upper bounds, the
% proposal xp=proposalFunc(x) has all of its entries that are less than
% lowerBoundOnX rounded up to lowerBoundOnX, and all of its entries greater
% than upperBoundOnX rounded down to upperBoundOnX before funcToOptimize is
% evaluated on xp (these bounds can be -inf and +inf to make them effectively
% ignored). The proposal is accepted if it improves the function value, or does
% not make it worse by more than epsilon. The routine terminates when timeDelta
% seconds have passed without the best value found so far of funcToOptimize
% improving by funcDelta.

%let's update our local search to vary epsilon and funcDelta; initial epsilon 
%provided will be an upper bound
function x=localSearch(funcToOptimize,proposalFunc,startingX,epsilon,lowerBoundOnX,upperBoundOnX,timeDelta,funcDelta)
    startTimer = scale(now());
    hardTimer = startTimer;
    initialDelta = funcDelta;

    while(true)    
        %make sure proposal is within bounds
        xp = arrayfun(@(x) rnd(x, lowerBoundOnX, upperBoundOnX), proposalFunc(startingX));
        
        %eval function at old value
        oldVal = funcToOptimize(startingX);
        
        %determine if proposal is valid
        if funcToOptimize(xp) <= (oldVal + epsilon)
            startingX = xp;
        end
        
        %check whether function value has changed enough          
        if abs(oldVal - funcToOptimize(startingX)) <= funcDelta
            currentTimer = scale(now());
            if ((currentTimer - startTimer) >= timeDelta)
                %run again if epsilon isn't small enough
                if (epsilon < .00001)
                    x = startingX; return;
                else
                    %decrease epsilon and return funcDelta to original val
                    funcDelta = initialDelta;
                    startTimer = scale(now());
                    hardTimer = startTimer;
                    epsilon = epsilon / 2;
                end
            end
        else
            startTimer = scale(now());
            
            %if we seem stuck, let's increase the funcDelta
            if abs(hardTimer - startTimer) > (timeDelta * 4)
                funcDelta = funcDelta * 2;
            end
        end
    end
end

%round value based on lower and upper bounds
function out=rnd(x, L, U)
  if x < L
    out = L;
  elseif x > U
    out = U;
  else 
    out = x;
  end
end

%scale now() output
function out=scale(t)
  out = t * 60^2 * 24;
end
  